# 쏙쏙 들어오는 함수형 코딩

## 액션과 계산, 데이터의 차이를 알기

### 액션

액션은 외부 세계에 영향을 주거나 받는 것을 말하며 호출 시점과 횟수에 의존한다.  
부수 효과, 부수 효과가 있는 함수, 순수하지 않은 함수라고 부르기도 한다.  
액션 안에는 계산과 데이터, 또 다른 액션이 숨어 있을지도 모른다.  
액션은 가능한 적게 사용해야 하며 가능한 작게 만들어야 한다.

### 계산

입력값으로 출력값을 만드는 것이다.  
실행 시점과 횟수에 관계없이 항상 같은 입력값에 대해 같은 출력값을 돌려준다.  
순수 함수, 수학 함수라고 부르기도 한다.  
계산은 더 작은 계산과 데이터로 나누고 연결할 수 있다.  
결정과 계획은 계산이 될 가능성이 높다.

### 데이터

이벤트에 대한 사실이며 일어난 일의 결과를 기록한 것이다.  
데이터는 데이터만 조합할 수 있다.

## 액션에서 계산 빼내기

### 함수에는 입력과 출력이 있다.

입력은 함수가 계산을 하기 위한 외부 정보이며 출력은 함수 밖으로 나오는 정보나 어떤 동작이다.  
함수를 부르는 이유는 결과가 필요하기 때문이며 원하는 결과를 얻으려면 입력이 필요하다.

입력과 출력은 명시적이거나 암묵적일 수 있다.  
함수에 암묵적 입력과 출력이 있으면 액션이 되므로 없애야 한다.

암묵적 입력은 인자 외 다른 입력이고 암묵적 출력은 리턴값 외 다른 출력이다.

- 암묵적 입력의 예: 전역변수 읽기
- 암묵적 출력의 예: 콘솔, 전역변수 수정, DOM 업데이트

### 계산 추출 과정

1. **계산 코드를 찾아 빼낸다.**  
   코드를 추출해 새로운 함수로 만든다.
2. **새 함수에 암묵적 입력과 출력을 찾는다.**  
   암묵적 입력은 함수를 부르는 동안 결과에 영향을 줄 수 있는 것을 말한다.  
   암묵적 출력은 함수 호출의 결과로 영향을 받는 것을 말한다.
3. **암묵적 입력은 인자로 암묵적 출력은 리턴값으로 바꾼다.**  
   인자와 리턴값은 바뀌지 않는 불변값으로 바꿔야 한다.

## 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

### 카피 온 라이트 원칙 세 단계

불변성을 유지하면서 값을 바꾸기 위해 아래 세 단계를 밟는다.

1. 복사본 만들기
2. 복사본 변경하기(원하는 만큼)
3. 본사본 리턴하기

카피 온 라이트로 구현한 쓰기 함수는 데이터를 바꾸지 않고 정보를 리턴하기 때문에 읽기가 된다.

### 불변 데이터 구조를 읽는 것은 계산입니다

변경 가능한 데이터를 읽는 것은 액션이다.  
쓰기는 데이터를 변경 가능한 구조로 만든다.  
어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터이다.  
불변 데이터 구조를 읽는 것은 계산이다.  
쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.

## 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

바꿀 수 없는 라이브러리나 레거시 코드가 데이터를 변경한다면 카피 온 라이트를 적용할 수 없다.  
방어적 복사는 카피 온 라이트 원칙을 지키면서 안전하게 함수를 사용할 수 있는 원칙이다.  
방어적 복사는 카피 온 라이트와는 다르게 깊은 복사를 하기 때문에 비용이 많이 든다.

### 방어적 복사 규칙

1. 데이터가 안전한 코드에서 나갈 때 복사하기
   1. 불변성 데이터를 위한 깊은 복사본을 만든다.
   2. 신뢰할 수 없는 코드로 복사본을 전달한다.
2. 안전한 코드로 데이터가 들어올 때 복사하기
   1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달한다.
   2. 복사본을 안전한 코드에서 사용한다.

## 계층형 설계

계층형 설계는 바로 아래 계층의 함수로 지금 계층의 함수를 만드는 방법이다.  
계층형 설계를 사용해 소프트웨어 설계를 위한 미적 감각을 키울 수 있다.

### 계층형 설계 감각을 키우기 위한 입력과 출력

- 입력
  - 함수 본문
    - 길이
    - 복잡성
    - 구체화 단계
    - 함수 호출
    - 프로그래밍 언어의 기능 사용
  - 계층 구조
    - 화살표 길이
    - 응집도
    - 구체화 단계
  - 함수 시그니처
    - 함수명
    - 인자 이름
    - 인잣값
    - 리턴값
- 출력
  - 조직화
    - 새로운 함수를 어디에 놓을지 결정
    - 함수를 다른 곳으로 이동
  - 구현
    - 구현 바꾸기
    - 함수 추출하기
    - 데이터 구조 바꾸기
  - 변경
    - 새 코드를 작성할 곳 선택하기
    - 적절한 수준의 구체화 단계 결정하기

### 패턴 1: 직접 구현

직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다.  
특정 함수가 알아야 할 필요가 없는 구체적인 내용을 담고 있으면 안된다.  
함수에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않아 읽기 어려워진다.  
호출 그래프를 그려가며 계층 구조의 설계 감각을 키울 수 있다.  
같은 계층에 있는 함수는 같은 목적을 가지고 있어야 한다.

### 패턴 2: 추상화 벽

추상화 벽을 통해 특정 계층의 함수는 중요한 세부 구현을 감추고 인터페이스를 제공한다.  
추상화 벽 위에 있는 함수는 데이터 구조를 몰라도 사용할 수 있다.  
추상화 벽으로 추상화 벽 아래에 있는 코드와 위에 있는 코드의 의존성을 없앨 수 있다.

추상화 벽은 아래와 같은 경우에 사용하면 좋다.

- 쉽게 구현을 바꾸기 위해
- 코드를 읽고 쓰기 쉽게 만들기 위해
- 팀 간에 조율해야 할 것을 줄이기 위해
- 주어진 문제에 집중하기 위해

### 패턴 3: 작은 인터페이스

작은 인터페이스 패턴은 새로운 코드를 추가할 위치에 관한 것이다.  
새로운 기능을 만들 때 하위 계층에 기능을 추가하거나 고치는 것보다 상위 계층에 만드는 것이 좋다.  
작은 인터페이스 패턴을 사용하면 하위 계층을 고치지 않고 상위 계층에서 문제를 해결할 수 있으며, 깨끗하고 단순하고 믿을 수 있는 인터페이스에 집중할 수 있다.  
상위 계층에 어떤 함수를 만들 때 가능한 현재 계층에 있는 함수로 구현하는 것이 작은 인터페이스를 실천하는 방법이다.

### 패턴 4: 편리한 계층

편리한 계층 패턴은 언제 패턴을 적용하고 또 언제 멈춰야 하는지 실용적인 방법을 알려준다.  
작업하는 코드가 편리하다고 느낀다면 설계는 조금 멈춰도 된다.  
구체적인 것을 너무 많이 알아야 하거나, 코드가 지저분하다고 느껴진다면 다시 패턴을 적용해야 한다.

### 호출 그래프가 코드에 대해 알려주는 것

- 유지보수성
  - 규칙: 위로 연결된 것이 적은 함수가 바꾸기 쉽다.
  - 핵심: 자주 바뀌는 코드는 가능한 위쪽에 있어야 한다.
- 테스트 가능성
  - 규칙: 위쪽으로 많이 연결된 함수를 테스트하는 것이 더 가치 있다.
  - 핵심: 아래쪽에 있는 함수를 테스트하는 것이 위쪽에 있는 함수를 테스트하는 것보다 가치 있다.
- 재사용성
  - 규칙: 아래쪽에 함수가 적을수록 더 재사용하기 좋다.
  - 핵심: 낮은 수준의 단계로 함수를 빼내면 재사용성이 더 높아진다.

## 일급 함수

### 일급 값

일급 값은 아래와 같은 일을 할 수 있다.

- 변수에 할당
- 함수의 인자로 넘기기
- 함수의 리턴값으로 받기
- 배열이나 객체에 담기

### 고차 함수

고차 함수는 인자로 함수를 받거나 리턴값으로 함수를 리턴할 수 있는 함수를 말한다.  
함수를 일급 값으로 사용할 수 있는 언어에서 고차 함수를 만들 수 있다.

### 암묵적 인자 드러내기

함수 이름에 있는 암묵적 인자는 함수의 이름으로 구분하는 코드의 냄새이다. 이 냄새는 코드로 다룰 수 없는 함수 이름 대신 일급 값인 인자로 바꾸는 암묵적 인자를 드러내기 리팩터링을 적용해서 없앨 수 있다.

```javascript
// 리팩터링 전
function setPriceByName(cart, name, price) {
  var item = cart[name];
  var newItem = objectSet(item, "price", price);
  var newCart = objectSet(cart, name, newItem);
  return newCart;
}

// 리팩터링 후
function setFieldByName(cart, name, field, value) {
  var item = cart[name];
  var newItem = objectSet(item, field, value);
  var newCart = objectSet(cart, name, newItem);
  return newCart;
}
```

### 본문을 콜백으로 바꾸기

동작을 추상화하기 위해 본문을 콜백으로 바꾸기 리팩터링을 사용할 수 있다.  
서로 다른 함수의 동작 차이를 일급 함수 인자로 만든다.

```javascript
function withLogging(f) {
  try {
    f();
  } catch (error) {
    logToSnapErrors(error);
  }
}
```

### 함수를 리턴하는 함수

코드에 반복되는 부분을 줄이기 위해 고차 함수를 사용하는 것이 중요하다.  
고차 함수는 많은 중복 코드를 없애 주지만 가독성을 해칠 수도 있다.

```javascript
function wrapLogging(f) {
  return function (arg) {
    try {
      f(arg);
    } catch (error) {
      logToSnapErrors(error);
    }
  };
}
```

## 함수형 도구 체이닝

체이닝을 통해 여러 단계를 하나로 조합할 수 있다.

```javascript
function biggestPurchasesBestCustomers(customers) {
  var bestCustomers = filter(
    customers,
    (customer) => customer.purchases.length >= 3
  );
  var biggestPurchases = map(bestCustomers, (customer) =>
    maxKey(customer.purchases, { total: 0 }, (purchase) => purchase.total)
  );

  return biggestPurchases;
}
```

각 단계에 이름을 붙이거나 콜백에 이름을 붙여서 체인을 명확하게 만들 수 있다.

```javascript
// 단계에 이름 붙이기
function selectBestCustomers(customers) {
  return filter(customers, (customer) => customer.purchases.length >= 3);
}

// ...
var bestCustomers = selectBestCustomers(customers);
// ...
```

```javascript
// 콜백에 이름 붙이기
function isGoodCustomer(customers) {
  return customer.purchases.length >= 3;
}

// ...
var bestCustomers = filter(customers, isGoodCustomer);
// ...
```

스트림 결합을 통해 체인을 최적화할 수 있다.

```javascript
// 값 하나에 map() 두 번 사용
var names = map(customers, getFullName);
var nameLengths = map(names, stringLength);

// map()을 한 번 사용
var nameLengths = map(customers, (customer) =>
  stringLength(getFullName(customer))
);
```

## 중첩된 데이터에 함수형 도구 사용하기

### 객체를 다루기 위한 고차 함수

`update()`를 사용하면 객체 안에서 값을 꺼내 변경하고 다시 설정하는 일을 수동으로 하지 않아도 된다.

```javascript
function update(object, key, modify) {
  var value = object[key];
  var newValue = modify(value);
  var newObject = objectSet(object, key, newValue);
  return newObject;
}
```

### 중첩된 객체를 다루기 위한 고차 함수

`nestedUpdate()`는 바꾸려고 하는 값이 어디 있는지 가리키는 키 경로만 알면 중첩된 데이터를 쉽게 바꿀 수 있다.

```javascript
function nestedUpdate(object, keys, modify) {
  if (keys.length === 0) {
    return modify(object);
  }

  var key1 = keys[0];
  var restOfKeys = drop_first(keys);

  return update(object, key1, function (value1) {
    return nestedUpdate(value1, restOfKeys, modify);
  });
}
```

### 안전한 재귀 사용법

1. 재귀를 멈추려면 종료 조건이 필요하다.
2. 재귀 함수는 최소 하나의 재귀 호출이 있어야 한다.
3. 최소 하나 이상의 인자가 점점 줄어들어야 한다.

### 깊이 중첩된 데이터에 추상화 벽 사용하기

깊이 중첩된 데이터는 모든 데이터 구조와 어떤 경로에 어떤 키가 있는지 기억해야 하므로 이해하기 어렵다.  
많은 키를 가지고 있는 깊이 중첩된 구조에 추상화 벽을 사용하면 알아야 할 것이 줄어듭니다.

## 타임라인 격리하기

타임라인은 액션을 순서대로 나열한 것이다.  
타임라인 다이어그램은 시간에 따른 액션 순서를 시각적으로 표시한 것이다.

### 타임라인 다이어그램 기본 규칙

타임라인 다이어그램으로 알 수 있는 중요한 두 가지 사실은 순서대로 실행되는 액션과 동시에 나란히 실행되는 액션이 있다는 것이다.  
이러한 두 종류의 액션을 타임라인 다이어그램으로 바꿀 때 두 가지 기본 규칙이 있다.

1. 두 액션이 순서대로 나타나면 같은 타임라인에 넣는다.
2. 두 액션이 동시에 실행되거나 순서를 예상할 수 없다면 분리된 타임라인에 넣는다.

동시에 실행되는 코드는 타임라인 다이어그램에 나란히 표현한다.  
타임라인에서 나란히 표현된 두개의 액션은 왼쪽 먼저, 오른쪽 먼저, 동시에 실행되는 세 가지 순서를 가질 수 있다.

### 놓칠 수 있는 액션 순서에 관한 두 가지 사실

모든 액션을 확인하고 어떤 순서로 실행되는지 이해하는 것은 중요하다.  
모든 언어는 별도의 실행 방법을 가지고 있어서 잘 알고 있어야 한다.

1. `++`와 `+=`는 사실 세 단계이다. (읽기, 더하기, 쓰기)
   만약 전역변수라면, 읽기와 쓰기가 액션이 된다.
2. 인자는 함수를 부르기 전에 실행된다. (읽기)
   만약 진역변수라면, 읽기가 액션이 된다.

### 서로 다른 언어, 서로 다른 스레드 모델

- **단일 스레드, 동기**  
  모든 것이 순서대로 실행되고 입출력을 사용하면 끝날 때까지 기다려야 한다.  
  네트워크를 통한 API 호출 같은 것은 다른 타임라인이 필요하다.
- **단일 스레드, 비동기**  
  입출력의 결과는 콜백으로 받을 수 있지만, 언제 끝날지 알 수 없기 때문에 다른 타임라인에 표현해야 한다.
- **멀티스레드**  
  새로운 스레드가 생기면 새로운 타임라인을 그려야 한다.
- **메시지 패싱 프로세스**  
  프로세스는 서로 메모리를 공유하지 않고 메시지로 통신한다.  
  서로 다른 타임라인에 있는 액션은 순서가 섞이지만, 메모리를 공유하지 않기 때문에 가능한 실행 순서가 많아도 문제가 되지 않는다.

### 좋은 타임라인의 원칙

타임라인을 사용하면서 좋은 타임라인의 원칙을 알면 코드를 개선하거나 더 이해하기 쉬운 코드를 만드는 데 도움이 된다.

1. 타임라인은 적을수록 이해하기 쉽다.
2. 타임라인은 짧을수록 이해하기 쉽다.
3. 공유하는 자원이 적을수록 이해하기 쉽다.
4. 자원을 공유한다면 서로 조율해야 한다.
5. 시간을 일급으로 다룬다.
